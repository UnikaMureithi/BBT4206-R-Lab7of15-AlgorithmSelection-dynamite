---
title: "Business Intelligence Lab Submission Markdown"
author: "Dynamite"
date: "4/11/2023"
output:
  github_document: 
    toc: yes
    toc_depth: 4
    fig_width: 6
    fig_height: 4
    df_print: default
editor_options:
  chunk_output_type: console
  markdown: 
    wrap: 72
---

# Student Details

+------------------------------------+-------------------------------+
| **Student ID Numbers and Names of  | 1.  136017 - C - Unika        |
| Group Members**                    |     Mureithi                  |
|                                    |                               |
|                                    | 2.  136804 - C - Joy Mutai    |
|                                    |                               |
|                                    | 3.  135864 - C - Winnie       |
|                                    |     Githua                    |
|                                    |                               |
|                                    | 4.  120313 - C - Daniel Obala |
|                                    |                               |
|                                    | 5.  133598 - C - Shirlene     |
|                                    |     Ouma                      |
+------------------------------------+-------------------------------+
| **GitHub Classroom Group Name**    | Dynamite                      |
+------------------------------------+-------------------------------+
| **Course Code**                    | BBT4206                       |
+------------------------------------+-------------------------------+
| **Course Name**                    | Business Intelligence II      |
+------------------------------------+-------------------------------+
| **Program**                        | Bachelor of Business          |
|                                    | Information Technology        |
+------------------------------------+-------------------------------+
| **Semester Duration**              | 21^st^ August 2023 to 28^th^  |
|                                    | November 2023                 |
+------------------------------------+-------------------------------+

# Setup Chunk

We start by installing all the required packages

```{r load_packages}
if (require("readr")) {
  require("readr")
} else {
  install.packages("readr", dependencies = TRUE,
                   repos = "https://cloud.r-project.org")
}

## naniar ----
if (require("naniar")) {
  require("naniar")
} else {
  install.packages("naniar", dependencies = TRUE,
                   repos = "https://cloud.r-project.org")
}

## ggplot2 ----
if (require("ggplot2")) {
  require("ggplot2")
} else {
  install.packages("ggplot2", dependencies = TRUE,
                   repos = "https://cloud.r-project.org")
}

## corrplot ----
if (require("corrplot")) {
  require("corrplot")
} else {
  install.packages("corrplot", dependencies = TRUE,
                   repos = "https://cloud.r-project.org")
}

## ggcorrplot ----
if (require("ggcorrplot")) {
  require("ggcorrplot")
} else {
  install.packages("ggcorrplot", dependencies = TRUE,
                   repos = "https://cloud.r-project.org")
}

if (!require("mlbench")) {
  install.packages("mlbench", dependencies = TRUE,
                   repos = "https://cloud.r-project.org")
}
library(mlbench)

if (!requireNamespace("GGally", quietly = TRUE)) {
  install.packages("GGally")
}
library(GGally)

if (!requireNamespace("stats", quietly = TRUE)) {
  install.packages("stats")
}
```

------------------------------------------------------------------------

**Note:** the following "*KnitR*" options have been set as the defaults
in this markdown:\
`knitr::opts_chunk$set(echo = TRUE, warning = FALSE, eval = TRUE, collapse = FALSE, tidy.opts = list(width.cutoff = 80), tidy = TRUE)`.

More KnitR options are documented here
<https://bookdown.org/yihui/rmarkdown-cookbook/chunk-options.html> and
here <https://yihui.org/knitr/options/>.

```{r setup, echo=TRUE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(
	eval = TRUE,
	echo = TRUE,
	warning = FALSE,
	collapse = FALSE,
	tidy = TRUE
)
```

------------------------------------------------------------------------

**Note:** the following "*R Markdown*" options have been set as the
defaults in this markdown:

> output:\
> \
> github_document:\
> toc: yes\
> toc_depth: 4\
> fig_width: 6\
> fig_height: 4\
> df_print: default\
> \
> editor_options:\
> chunk_output_type: console

# Load the dataset

Load the BreastCancer dataset

```{r Load dataset}
# Load the Breast Cancer dataset
data("BreastCancer")

# View the structure of the dataset
str(BreastCancer)

# Get the dimensions of the dataset (number of rows and columns)
dim(BreastCancer)

# View the first few rows of the dataset
head(BreastCancer)

# Get summary statistics for the dataset
summary(BreastCancer)

# Check for missing data in the Breast Cancer dataset
# Are there missing values in the dataset?
any_na(BreastCancer)

# How many missing values?
n_miss(BreastCancer)

# What is the proportion of missing data in the entire dataset?
prop_miss(BreastCancer)

# What is the number and percentage of missing values grouped by each variable?
miss_var_summary(BreastCancer)

# Which variables contain the most missing values?
gg_miss_var(BreastCancer)

# Which combinations of variables are missing together?
#gg_miss_upset(BreastCancer)

# Where are missing values located (the shaded regions in the plot)?
vis_miss(BreastCancer) +
  theme(axis.text.x = element_text(angle = 80))

# Check for missing values in 'Bare.nuclei'
any(is.na(BreastCancer$Bare.nuclei))

# Convert 'Bare.nuclei' to numeric (if not already)
BreastCancer$Bare.nuclei <- as.numeric(BreastCancer$Bare.nuclei)

# Impute missing values with the mean of the non-missing values
mean_value <- mean(BreastCancer$Bare.nuclei, na.rm = TRUE)
BreastCancer$Bare.nuclei[is.na(BreastCancer$Bare.nuclei)] <- mean_value

# Check if missing values have been imputed
any(is.na(BreastCancer$Bare.nuclei))

# Check the column names of the dataset
colnames(BreastCancer)
```

# Exploratory Data analysis

```{r EDA }
# Visualize the distribution of the target variable
ggplot(BreastCancer, aes(x = Class)) +
  geom_bar(fill = "skyblue") +
  labs(title = "Distribution of Diagnosis (Malignant and Benign)")

# Identify columns that are not numeric or integer
non_numeric_cols <- sapply(BreastCancer, function(x) !is.numeric(x) && !is.integer(x))

# Convert non-numeric columns to numeric
BreastCancer[, non_numeric_cols] <- lapply(BreastCancer[, non_numeric_cols], as.numeric)

# Compute the correlation matrix
correlation_matrix <- cor(BreastCancer)

# Visualize the correlation matrix
corrplot(correlation_matrix, method = "color")

# Select only the numeric columns for the scatter plot
numeric_cols <- sapply(BreastCancer, is.numeric)
numeric_data <- BreastCancer[, numeric_cols]

# Create scatter plots
pairs(numeric_data)

# Select only the numeric columns for standardization
numeric_cols <- sapply(BreastCancer, is.numeric)
numeric_data <- BreastCancer[, numeric_cols]

# Standardize the data
scaled_data <- scale(numeric_data)

# Convert the scaled data back to a data frame
scaled_data <- as.data.frame(scaled_data)

# add the column names back to the scaled_data data frame
colnames(scaled_data) <- colnames(numeric_data)
```

# Perform Clustering

\`\`\`{r Perform clustering } \# Specify the number of clusters you want
to create (e.g., 2 for benign and malignant) num_clusters \<- 2

# Perform K-Means Clustering

kmeans_result \<- kmeans(scaled_data, centers = num_clusters)

# Add the cluster assignments to your original dataset

BreastCancer$cluster <- kmeans_result$cluster

# The 'cluster' column in 'BreastCancer' now contains the cluster assignments

# view the cluster centers using:

kmeans_result\$centers

# To visualize the clusters we use scatter plot

ggplot(BreastCancer, aes(x = Cl.thickness, y = Cell.size, color =
factor(cluster))) + geom_point() + labs(title = "K-Means Clustering of
Breast Cancer Data")

# Calculate the total within-cluster variance for different numbers of clusters

wcss \<- numeric(length = 10) \# Initialize a vector to store
within-cluster variance

for (i in 1:10) { kmeans_model \<- kmeans(scaled_data, centers = i)
wcss[i] \<- kmeans_model\$tot.withinss }

wcss \<- numeric(length = 10) \# Initialize a vector to store
within-cluster variance

# Create a scree plot to identify the optimal number of clusters

plot(1:10, wcss, type = "b", xlab = "Number of Clusters", ylab = "Total
Within-Cluster Variance", main = "Scree Plot")

# After identifying the elbow point, you can choose the optimal number of clusters.

# For example, if the elbow point is at k=3, you can perform K-Means clustering with 3 clusters.

optimal_clusters \<- 3 \# Replace with the actual optimal number of
clusters

# Perform K-Means clustering with the optimal number of clusters

kmeans_result \<- kmeans(scaled_data, centers = optimal_clusters)

# Add the cluster assignments to your original dataset

BreastCancer$cluster <- kmeans_result$cluster

# view the cluster centers using:

kmeans_result\$centers

# To visualize the clusters, you can create a scatter plot

# using a subset of the variables (e.g., 'Cl.thickness' and 'Cell.size')

library(ggplot2) ggplot(BreastCancer, aes(x = Cl.thickness, y =
Cell.size, color = factor(cluster))) + geom_point() + labs(title =
"K-Means Clustering of Breast Cancer Data") \`\`\`\`
